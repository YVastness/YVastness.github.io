<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git 提交规范</title>
      <link href="/2023/04/12/Git%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/"/>
      <url>/2023/04/12/Git%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure><p>大致分为三个部分(使用空行分割):</p><ol><li>标题行: 必填, 描述主要修改类型和内容</li><li>主题内容: 描述为什么修改, 做了什么样的修改, 以及开发的思路等等</li><li>页脚注释: 放 Breaking Changes 或 Closed Issues</li></ol><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>commit 的类型：</p><ul><li>feat: 新功能、新特性</li><li>fix: 修改 bug</li><li>perf: 更改代码，以提高性能（在不影响代码内部行为的前提下，对程序性能进行优化）</li><li>refactor: 代码重构（重构，在不影响代码内部行为、功能下的代码修改）</li><li>docs: 文档修改</li><li>style: 代码格式修改, 注意不是 css 修改（例如分号修改）</li><li>test: 测试用例新增、修改</li><li>build: 影响项目构建或依赖项修改</li><li>revert: 恢复上一次提交</li><li>ci: 持续集成相关文件修改</li><li>chore: 其他修改（不在上述类型中的修改）</li><li>release: 发布新版本</li><li>workflow: 工作流相关文件修改</li></ul><h3 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h3><p>commit 影响的范围, 比如: route, component, utils, build…</p><h3 id="subject"><a href="#subject" class="headerlink" title="subject"></a>subject</h3><p>commit 的概述</p><h3 id="body"><a href="#body" class="headerlink" title="body"></a>body</h3><p>commit 具体修改内容, 可以分为多行.</p><h3 id="footer"><a href="#footer" class="headerlink" title="footer"></a>footer</h3><p>一些备注, 通常是 BREAKING CHANGE 或修复的 bug 的链接.</p><h2 id="约定式提交规范"><a href="#约定式提交规范" class="headerlink" title="约定式提交规范"></a>约定式提交规范</h2><p>以下内容来源于：<a href="https://link.zhihu.com/?target=https://www.conventionalcommits.org/zh-hans/v1.0.0-beta.4/">https://www.conventionalcommits.org/zh-hans/v1.0.0-beta.4/</a></p><ul><li>每个提交都必须使用类型字段前缀，它由一个名词组成，诸如 <code>feat</code> 或 <code>fix</code> ，其后接一个可选的作用域字段，以及一个必要的冒号（英文半角）和空格。</li><li>当一个提交为应用或类库实现了新特性时，必须使用 <code>feat</code> 类型。</li><li>当一个提交为应用修复了 <code>bug</code> 时，必须使用 <code>fix</code> 类型。</li><li>作用域字段可以跟随在类型字段后面。作用域必须是一个描述某部分代码的名词，并用圆括号包围，例如： <code>fix(parser):</code></li><li>描述字段必须紧接在类型&#x2F;作用域前缀的空格之后。描述指的是对代码变更的简短总结，例如： <code>fix: array parsing issue when multiple spaces were contained in string.</code></li><li>在简短描述之后，可以编写更长的提交正文，为代码变更提供额外的上下文信息。正文必须起始于描述字段结束的一个空行后。</li><li>在正文结束的一个空行之后，可以编写一行或多行脚注。脚注必须包含关于提交的元信息，例如：关联的合并请求、Reviewer、破坏性变更，每条元信息一行。</li><li>破坏性变更必须标示在正文区域最开始处，或脚注区域中某一行的开始。一个破坏性变更必须包含大写的文本 <code>BREAKING CHANGE</code>，后面紧跟冒号和空格。</li><li>在 <code>BREAKING CHANGE:</code> 之后必须提供描述，以描述对 API 的变更。例如： <code>BREAKING CHANGE: environment variables now take precedence over config files.</code></li><li>在提交说明中，可以使用 <code>feat</code> 和 <code>fix</code> 之外的类型。</li><li>工具的实现必须不区分大小写地解析构成约定式提交的信息单元，只有 <code>BREAKING CHANGE</code> 必须是大写的。</li><li>可以在类型&#x2F;作用域前缀之后，: 之前，附加 <code>!</code> 字符，以进一步提醒注意破坏性变更。当有 <code>!</code> 前缀时，正文或脚注内必须包含 <code>BREAKING CHANGE: description</code></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="fix"><a href="#fix" class="headerlink" title="fix"></a>fix</h3><p>如果修复的这个BUG只影响当前修改的文件，可不加范围。如果影响的范围比较大，要加上范围描述。</p><p>例如这次 BUG 修复影响到全局，可以加个 global。如果影响的是某个目录或某个功能，可以加上该目录的路径，或者对应的功能名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 示例1</span><br><span class="line">fix(global):修复checkbox不能复选的问题</span><br><span class="line">// 示例2 下面圆括号里的 common 为通用管理的名称</span><br><span class="line">fix(common): 修复字体过小的BUG，将通用管理下所有页面的默认字体大小修改为 14px</span><br><span class="line">// 示例3</span><br><span class="line">fix: value.length -&gt; values.length</span><br></pre></td></tr></table></figure><h3 id="feat"><a href="#feat" class="headerlink" title="feat"></a>feat</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">feat: 添加网站主页静态页面</span><br><span class="line"></span><br><span class="line">这是一个示例，假设对点检任务静态页面进行了一些描述。</span><br><span class="line"> </span><br><span class="line">这里是备注，可以是放BUG链接或者一些重要性的东西。</span><br></pre></td></tr></table></figure><h3 id="chore"><a href="#chore" class="headerlink" title="chore"></a>chore</h3><p>chore 的中文翻译为日常事务、例行工作，顾名思义，即不在其他 commit 类型中的修改，都可以用 chore 表示。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://link.zhihu.com/?target=https://www.conventionalcommits.org/zh-hans/v1.0.0-beta.4/">约定式提交</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git reset 命令</title>
      <link href="/2023/03/05/git%20reset%20%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/03/05/git%20reset%20%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><code>git reset</code> 命令用于回退版本，可以指定退回某一次提交的版本。</p><p>git reset 命令语法格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset [--soft | --mixed | --hard] [HEAD]</span><br></pre></td></tr></table></figure><p><strong>--mixed</strong> 为默认，可以不用带该参数，用于重置暂存区的文件与上一次的提交(commit)保持一致，工作区文件内容保持不变。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset  [HEAD] </span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD^            # 回退所有内容到上一个版本  </span><br><span class="line">$ git reset HEAD^ hello.php  # 回退 hello.php 文件的版本到上一个版本  </span><br><span class="line">$ git  reset  052e           # 回退到指定版本</span><br></pre></td></tr></table></figure><p><strong>--soft</strong> 参数用于回退到某个版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --soft HEAD~3   <span class="comment"># 回退上上上一个版本 </span></span><br></pre></td></tr></table></figure><p><strong>--hard</strong> 参数撤销工作区中所有未提交的修改内容，将暂存区与工作区都回到上一次版本，并删除之前的所有信息提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD~3  <span class="comment"># 回退上上上一个版本  </span></span><br><span class="line">$ git reset –hard bae128  <span class="comment"># 回退到某个版本回退点之前的所有信息。 </span></span><br><span class="line">$ git reset --hard origin/master    <span class="comment"># 将本地的状态回退到和远程的一样 </span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong>谨慎使用 <strong>–-hard</strong> 参数，它会删除回退点之前的所有信息。</p><p><strong>HEAD 说明：</strong></p><ul><li><p>HEAD 表示当前版本</p></li><li><p>HEAD^ 上一个版本</p></li><li><p>HEAD^^ 上上一个版本</p></li><li><p>HEAD^^^ 上上上一个版本</p></li><li><p>以此类推…</p></li></ul><p>可以使用 ～数字表示</p><ul><li><p>HEAD~0 表示当前版本</p></li><li><p>HEAD~1 上一个版本</p></li><li><p>HEAD^2 上上一个版本</p></li><li><p>HEAD^3 上上上一个版本</p></li><li><p>以此类推…</p></li></ul><h3 id="git-reset-HEAD"><a href="#git-reset-HEAD" class="headerlink" title="git reset HEAD"></a>git reset HEAD</h3><p>git reset HEAD 命令用于取消已缓存的内容。</p><p>我们先改动文件 README 文件，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Runoob Git 测试</span></span><br><span class="line"><span class="comment"># 菜鸟教程 </span></span><br></pre></td></tr></table></figure><p>hello.php 文件修改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;菜鸟教程：www.runoob.com&#x27;</span>;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;菜鸟教程：www.runoob.com&#x27;</span>;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;菜鸟教程：www.runoob.com&#x27;</span>;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>现在两个文件修改后，都提交到了缓存区，我们现在要取消其中一个的缓存，操作如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line">    M README</span><br><span class="line">    M hello.php</span><br><span class="line">$ git add .</span><br><span class="line">$ git status -s</span><br><span class="line">M  README</span><br><span class="line">M  hello.php</span><br><span class="line">$ git reset HEAD hello.php </span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M    hello.php</span><br><span class="line">$ git status -s</span><br><span class="line">M  README</span><br><span class="line">    M hello.php</span><br></pre></td></tr></table></figure><p>现在你执行 git commit，只会将 README 文件的改动提交，而 hello.php 是没有的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">&#x27;修改&#x27;</span></span><br><span class="line">[master f50cfda] 修改</span><br><span class="line">    1 file changed, 1 insertion(+)</span><br><span class="line">$ git status -s</span><br><span class="line">    M hello.php</span><br></pre></td></tr></table></figure><p>可以看到 hello.php 文件的修改并未提交。</p><p>这时我们可以使用以下命令将 hello.php 的修改提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -am <span class="string">&#x27;修改 hello.php 文件&#x27;</span></span><br><span class="line">[master 760f74d] 修改 hello.php 文件</span><br><span class="line">    1 file changed, 1 insertion(+)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure><p>简而言之，执行 git reset HEAD 以取消之前 git add 添加，但不希望包含在下一提交快照中的缓存。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git remote 命令</title>
      <link href="/2023/03/03/git%20remote%20%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/03/03/git%20remote%20%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><code>git remote</code>命令用于在远程仓库的操作。</p><p>显示所有远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p>以下我们先载入远程仓库，然后查看信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/tianqixin/runoob-git-test  </span><br><span class="line">$ <span class="built_in">cd</span> runoob-git-test</span><br><span class="line">$ git remote -v  </span><br><span class="line">origin  https://github.com/tianqixin/runoob-git-test (fetch)  </span><br><span class="line">origin  https://github.com/tianqixin/runoob-git-test (push)</span><br></pre></td></tr></table></figure><p><strong>origin</strong> 为远程地址的别名。</p><p>显示某个远程仓库的信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show [remote]</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git remote show https://github.com/tianqixin/runoob-git-test</span><br><span class="line">* remote https://github.com/tianqixin/runoob-git-test</span><br><span class="line">  Fetch URL: https://github.com/tianqixin/runoob-git-test</span><br><span class="line">  Push  URL: https://github.com/tianqixin/runoob-git-test</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Local ref configured <span class="keyword">for</span> <span class="string">&#x27;git push&#x27;</span>:</span><br><span class="line">    master pushes to master (<span class="built_in">local</span> out of <span class="built_in">date</span>)</span><br></pre></td></tr></table></figure><p>添加远程版本库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add [shortname] [url]</span><br></pre></td></tr></table></figure><p>shortname 为本地的版本库，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交到 Github</span></span><br><span class="line">$ git remote add origin git@github.com:tianqixin/runoob-git-test.git</span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure><p>其他相关命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="built_in">rm</span> name  <span class="comment"># 删除远程仓库</span></span><br><span class="line">git remote rename old_name new_name  <span class="comment"># 修改仓库名</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git mv 和 mv 的区别</title>
      <link href="/2023/03/02/git%20mv%E5%92%8Cmv%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/03/02/git%20mv%E5%92%8Cmv%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p><code>git mv</code>的执行过程：</p><ol><li><p>创建一个和之前文件内容一样的文件，文件名为新的文件名</p></li><li><p>将原来的文件删除</p></li><li><p>将删除的文件添加到暂存区</p></li><li><p>将新建的文件添加到暂存区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span> on master</span><br><span class="line">❯ git <span class="built_in">mv</span> 2.txt 22.txt</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> on master [»]</span><br><span class="line">❯ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        renamed:    2.txt -&gt; 22.txt</span><br></pre></td></tr></table></figure></li></ol><p><code>mv</code>的执行过程：只是重命名了一个文件。</p><p>但是 git 识别文件变动为：</p><ol><li>创建一个和之前文件内容一样的文件，文件名为新的文件名</li><li>将原来的文件删除</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span> on master</span><br><span class="line">❯ <span class="built_in">mv</span> 3.txt 33.txt</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> on master [✘?]</span><br><span class="line">❯ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add/rm &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        deleted:    3.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        33.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>结论：</strong><code>git mv</code>和<code>mv</code>的区别就是<code>mv</code>最后没有把工作区的文件添加到暂存区。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 增强命令</title>
      <link href="/2022/12/02/git/"/>
      <url>/2022/12/02/git/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>命令</th><th>介绍</th></tr></thead><tbody><tr><td>git commit -a</td><td>参数设置修改文件后不需要执行 git add 命令，直接来提交</td></tr><tr><td>git add -u</td><td>表示将已跟踪文件中的修改和删除的文件添加到暂存区，不包括新增加的文件</td></tr><tr><td>git status -s</td><td>显示短的消息</td></tr><tr><td>git restore [–worktree]</td><td>删除工作区指定文件最后修改</td></tr><tr><td>git restore –staged</td><td>删除暂存区指定文件最后修改</td></tr><tr><td>git rm</td><td>将文件从工作区中删除</td></tr><tr><td>git rm –cached</td><td>把文件从暂存区域移除</td></tr><tr><td>git diff</td><td>显示暂存区和工作区的差异</td></tr><tr><td>git diff –staged</td><td>显示暂存区和上一次提交(commit)的差异</td></tr><tr><td>git diff [first-commit]…[second-commit]</td><td>显示两次提交之间的差异</td></tr><tr><td>git mv</td><td>用于移动或重命名一个文件、目录或软连接</td></tr><tr><td>git log –graph</td><td>查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项</td></tr><tr><td>git push -u</td><td>第一次提交需要加 -u参数后，后面的提交就直接可以 git push</td></tr><tr><td>git branch -r</td><td></td></tr><tr><td>git branch -d</td><td></td></tr></tbody></table><ol><li>–cached 和 –staged 是同义词</li><li>restore 恢复;恢复原状</li><li>verbose 冗长的;详细信息</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>/ 和 /* 和 /** 的区别</title>
      <link href="/2022/12/01/%E6%96%9C%E6%9D%A0%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/12/01/%E6%96%9C%E6%9D%A0%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="一、亲测-x2F-和-x2F-区别"><a href="#一、亲测-x2F-和-x2F-区别" class="headerlink" title="一、亲测 &#x2F; 和 &#x2F;* 区别"></a>一、亲测 &#x2F; 和 &#x2F;* 区别</h3><p>在 springboot 中建了一个过滤器，测试：</p><p><img src="https://raw.githubusercontent.com/YVastness/picture-upload/main/1001313-20190212212942450-433613516.png"></p><p>当请求为<code>/user/login</code>的时候可以被拦截，当为<code>/page/login.html</code>页面的时候不拦截：</p><p><img src="https://raw.githubusercontent.com/YVastness/picture-upload/main/1001313-20190212213608480-1119617961.png"></p><p> 当请求为<code>/user/login</code>的时候可以被拦截，当为<code>/page/login.html</code>页面的时候也会被拦截。</p><p><strong>所以综上，&#x2F;不会拦截页面，只会拦截路径，&#x2F;* 会拦截路径和页面。</strong></p><h3 id="二、-x2F-和-x2F"><a href="#二、-x2F-和-x2F" class="headerlink" title="二、&#x2F;*  和  &#x2F;**"></a>二、&#x2F;*  和  &#x2F;**</h3><p>&#x2F;* 是拦截所有的文件夹，不包含子文件夹<br>&#x2F;** 是拦截所有的文件夹及里面的子文件夹</p><p>相当于&#x2F;*只有后面一级</p><p>&#x2F;** 可以包含多级</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis中#{}和${}的区别</title>
      <link href="/2022/11/12/Mybatis%E4%B8%AD%E5%8D%A0%E4%BD%8D%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/11/12/Mybatis%E4%B8%AD%E5%8D%A0%E4%BD%8D%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>简明的解释:</p><ul><li><code>#&#123;&#125;</code>是预编译处理，<code>$ &#123;&#125;</code>是字符串替换（当做占位符来用）。</li><li>mybatis 在处理<code>#&#123;&#125;</code>时，会将 sql 中的<code>#&#123;&#125;</code>替换为?号，调用 PreparedStatement 的 set 方法来赋值；</li><li>mybatis在处理时，就是把 {} 时，就是把 {} 替换成变量的值。</li><li>在某些特殊场合下只能用${}，不能用#{}。例如：在使用排序时<code>ORDER BY $&#123;id&#125;</code>，如果使用#{id}，则会被解析成ORDER BY “id”,这显然是一种错误的写法。</li><li>使用 #{} 可以有效的防止SQL注入，提高系统安全性。</li></ul><h2 id="到此结束即可"><a href="#到此结束即可" class="headerlink" title="到此结束即可"></a><strong>到此结束即可</strong></h2><p><strong>解决SQL注入的办法就是预编译处理</strong></p><p><strong>使用 #{} 进行预编译处理</strong>，可以有效的防止SQL注入，提高系统安全性。</p><p>        预编译的机制。预编译是提前对SQL语句进行预编译，而其后注入的参数将不会再进行SQL编译。我们知道，SQL注入是发生在编译的过程中，因为注入sql语句常用的字符如:单引号**(‘)**和井号(#)进行恶意地闭合和注释，改变了我萌的原有句子，最后被编译执行了恶意操作。而预编译机制则可以很好的防止SQL注入。</p><p>想了解提升sql注入的可以试着理解下面的一点知识</p><h3 id="关于sql注释的简单解释"><a href="#关于sql注释的简单解释" class="headerlink" title="关于sql注释的简单解释"></a><strong>关于sql注释的简单解释</strong></h3><p><strong>假设下方语句是我萌自己写的做登录用户的java后台部分语句，我们想的是只有账号密码正确才可以登录</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span><span class="string">&quot;select * from table where id = &#x27;&quot;</span>+ admin +<span class="string">&quot;&#x27;and password =&#x27;&quot;</span>+password+<span class="string">&quot;&#x27;&quot;</span>; <span class="comment">//拼接参数</span></span><br><span class="line"></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">resultResultset</span> <span class="operator">=</span> statement.executeQuery(sql);<span class="comment">//执行sql语句</span></span><br></pre></td></tr></table></figure><p>但如果提交表单的数据是 <strong>admin的是 ‘ or 1 &#x3D; 1 #</strong>   然后password 随便填吧 比如 hj</p><blockquote><p><strong>那么sql句子变成:</strong> </p><p><strong>select * from table where id &#x3D; ‘ ‘ or 1 &#x3D; 1 # ‘ and password &#x3D;’ hj ‘;</strong></p></blockquote><p><strong>注意这时句子中的 # 井号会把后面的 ‘ and password &#x3D;’ hj ‘; 注释掉而无法判断，因为or 1 &#x3D; 1 这一句会告诉数据库是正确的，然后我萌就能基于这个原理实现偷偷给自己的数据库干坏事了。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 分支篇之远程分支</title>
      <link href="/2022/11/11/Git%20%E5%88%86%E6%94%AF%E7%AF%87%E4%B9%8B%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF/"/>
      <url>/2022/11/11/Git%20%E5%88%86%E6%94%AF%E7%AF%87%E4%B9%8B%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文转载自<a href="https://gitee.com/progit/3-Git-%E5%88%86%E6%94%AF.html#3.5-%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">Pro Git(中文版)</a></p></blockquote><p>  <strong>本节讲解命令</strong>：<code>git push &lt;远程仓库&gt; &lt;本地分支&gt;:&lt;远程分支&gt;</code>、<code>git fetch &lt;远程仓库&gt;</code>、<code>git pull &lt;远程仓库&gt; &lt;远程分支&gt;:&lt;本地分支&gt;</code>。</p><h2 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h2><p>  远程分支（remote branch）是对远程仓库中的分支的索引。它们是一些无法移动的本地分支；只有在 Git 进行网络交互时才会更新。远程分支就像是书签，提醒着你上次连接远程仓库时上面各分支的位置。</p><p>  我们用 <code>远程仓库名/分支名</code> 这样的形式表示远程分支。比如我们想看看上次和 origin 仓库进行通讯时 master 分支的样子，就应该查看 <code>origin/master</code> 分支。如果你和同伴一起修复某个问题，但他们先推送了一个 iss53 分支到远程仓库，虽然你可能也有一个本地的 iss53 分支，但指向服务器上最新更新的却应该是 <code>origin/iss53</code> 分支。</p><p>  可能有点乱，我们不妨举例说明。假设你们团队有个地址为 git.ourcompany.com 的 Git 服务器。如果你从这里克隆，Git 会自动为你将此远程仓库命名为 origin，并下载其中所有的数据，建立一个指向它的 master 分支的指针，在本地命名为 <code>origin/master</code>，但你无法在本地更改其数据。接着，Git 建立一个属于你自己的本地 master 分支，始于 origin 上 master 分支相同的位置，你可以就此开始工作。<br><img src="https://raw.githubusercontent.com/YVastness/picture-upload/main/bf60f1b6122646b8b36e23e94ae4acfc.png" alt="在这里插入图片描述"><br>  如果你在本地 master 分支做了些改动，与此同时，其他人向 git.ourcompany.com 推送了他们的更新，那么服务器上的 master 分支就会向前推进，而于此同时，你在本地的提交历史正朝向不同方向发展。不过只要你不和服务器通讯，你的 <code>origin/master</code> 指针仍然保持原位不会移动。<br><img src="https://raw.githubusercontent.com/YVastness/picture-upload/main/48dd488232ad4fdc8ad21b89e1a75fba.png" alt="在这里插入图片描述"></p><h2 id="拉取远程分支"><a href="#拉取远程分支" class="headerlink" title="拉取远程分支"></a>拉取远程分支</h2><p>  可以运行 <code>git fetch origin</code> 来同步远程服务器上的数据到本地。该命令首先找到 origin 是哪个服务器（本例为 git.ourcompany.com），从上面获取你尚未拥有的数据，更新你本地的数据库，然后把 <code>origin/master</code> 的指针移到它最新的位置上。<br><img src="https://raw.githubusercontent.com/YVastness/picture-upload/main/734f9ce89a7e4eee8560a3faae58a0e3.png" alt="在这里插入图片描述"><br>  为了演示拥有多个远程分支（在不同的远程服务器上）的项目是如何工作的，我们假设你还有另一个仅供你的敏捷开发小组使用的内部服务器 git.team1.ourcompany.com。可以用第二章中提到的 git remote add 命令把它加为当前项目的远程分支之一。我们把它命名为 teamone，以便代替完整的 Git URL 以方便使用。<br><img src="https://raw.githubusercontent.com/YVastness/picture-upload/main/31d0c08c26354283a94a32c2ba9b4e09.png" alt="在这里插入图片描述"><br>  现在你可以用 <code>git fetch teamone</code> 来获取小组服务器上你还没有的数据了。由于当前该服务器上的内容是你 origin 服务器上的子集，Git 不会下载任何数据，而只是简单地创建一个名为 <code>teamone/master</code> 的远程分支，指向 teamone 服务器上 master 分支所在的提交对象 31b8e。<br><img src="https://raw.githubusercontent.com/YVastness/picture-upload/main/5278a26b39f54d7bac2a3364d1ac9016.png" alt="在这里插入图片描述"><br>  还可以用 <code>git pull &lt;远程仓库&gt; &lt;远程分支&gt;:&lt;本地分支&gt;</code> 来进行拉取数据并且合并分支。</p><h2 id="推送本地分支"><a href="#推送本地分支" class="headerlink" title="推送本地分支"></a>推送本地分支</h2><p>  要想和其他人分享某个本地分支，你需要把它推送到一个你拥有写权限的远程仓库。<br>  你创建的本地分支不会因为你的提交操作而被自动同步到你引入的远程服务器上，你需要明确地执行推送分支的操作。换句话说，对于无意分享的分支，你尽管保留为私人分支好了，而只推送那些协同工作要用到的特性分支。<br>  如果你有个叫 serverfix 的分支需要和他人一起开发，可以运行 <code>git push 远程仓库名 分支名</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin serverfix</span><br><span class="line">    Counting objects: 20, done.</span><br><span class="line">    Compressing objects: 100% (14/14), done.</span><br><span class="line">    Writing objects: 100% (15/15), 1.74 KiB, done.</span><br><span class="line">    Total 15 (delta 5), reused 0 (delta 0)</span><br><span class="line">    To git@github.com:schacon/simplegit.git</span><br><span class="line">    * [new branch] serverfix -&gt; serverfix</span><br></pre></td></tr></table></figure><p>  这里其实走了一点捷径。Git 自动把 serverfix 分支名扩展为 <code>refs/heads/serverfix:refs/heads/serverfix</code>，意为“取出我在本地的 serverfix 分支，推送到远程仓库的 serverfix 分支中去”。我们将在第九章进一步介绍 <code>refs/heads/</code> 部分的细节，不过一般使用的时候都可以省略它。也可以运行 <code>git push origin serverfix:serverfix</code> 来实现相同的效果，它的意思是“上传我本地的 serverfix 分支到远程仓库中去，仍旧称它为 serverfix 分支”。通过此语法，你可以把本地分支推送到某个命名不同的远程分支：若想把远程分支叫作 awesomebranch，可以用 <code>git push origin serverfix:awesomebranch</code> 来推送数据。<br>  接下来，当你的协作者再次从服务器上获取数据时，他们将得到一个新的远程分支 <code>origin/serverfix</code>，并指向服务器上 serverfix 所指向的版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin</span><br><span class="line">    remote: Counting objects: 20, done.</span><br><span class="line">    remote: Compressing objects: 100% (14/14), done.</span><br><span class="line">    remote: Total 15 (delta 5), reused 0 (delta 0)</span><br><span class="line">    Unpacking objects: 100% (15/15), done.</span><br><span class="line">    From git@github.com:schacon/simplegit</span><br><span class="line">    * [new branch] serverfix -&gt; origin/serverfix</span><br></pre></td></tr></table></figure><p>  值得注意的是，在 fetch 操作下载好新的远程分支之后，你仍然无法在本地编辑该远程仓库中的分支。换句话说，在本例中，你不会有一个新的 serverfix 分支，有的只是一个你无法移动的 origin&#x2F;serverfix 指针。</p><p>  如果要把该远程分支的内容合并到当前分支，可以运行 <code>git merge origin/serverfix</code>。如果想要一份自己的 serverfix 来开发，可以在远程分支的基础上分化出一个新的分支来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b serverfix origin/serverfix</span><br><span class="line">    Branch serverfix set up to track remote branch refs/remotes/origin/serverfix.</span><br><span class="line">    Switched to a new branch &quot;serverfix&quot;</span><br></pre></td></tr></table></figure><p>  这会切换到新建的 serverfix 本地分支，其内容同远程分支 origin&#x2F;serverfix 一致，这样你就可以在里面继续开发了。</p><h2 id="跟踪远程分支"><a href="#跟踪远程分支" class="headerlink" title="跟踪远程分支"></a>跟踪远程分支</h2><p>  从远程分支 checkout 出来的本地分支，称为跟踪分支 (tracking branch)。<strong>跟踪分支是一种和某个远程分支有直接联系的本地分支</strong>。在跟踪分支里输入 <code>git push</code>，Git 会自行推断应该向哪个服务器的哪个分支推送数据。同样，在这些分支里运行 <code>git pull</code> 会获取所有远程索引，并把它们的数据都合并到本地分支中来。</p><h2 id="自动创建的跟踪分支"><a href="#自动创建的跟踪分支" class="headerlink" title="自动创建的跟踪分支"></a>自动创建的跟踪分支</h2><p>  在克隆仓库时，Git 通常会自动创建一个名为 master 的分支来跟踪 origin&#x2F;master。这正是 git push 和 git pull 一开始就能正常工作的原因。当然，你可以随心所欲地设定为其它跟踪分支，比如 origin 上除了 master 之外的其它分支。刚才我们已经看到了这样的一个例子：<code>git checkout -b [分支名] [远程名]/[分支名]</code>。如果你有 1.6.2 以上版本的 Git，还可以用 –track 选项简化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout --track origin/serverfix</span><br><span class="line">    Branch serverfix set up to track remote branch refs/remotes/origin/serverfix.</span><br><span class="line">    Switched to a new branch &quot;serverfix&quot;</span><br></pre></td></tr></table></figure><p>  要为本地分支设定不同于远程分支的名字，只需在第一个版本的命令里换个名字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b sf origin/serverfix</span><br><span class="line">    Branch sf set up to track remote branch refs/remotes/origin/serverfix.</span><br><span class="line">    Switched to a new branch &quot;sf&quot;</span><br></pre></td></tr></table></figure><p>  现在你的本地分支 sf 会自动将推送和抓取数据的位置定位到 origin&#x2F;serverfix 了。</p><h2 id="手动设置跟踪分支"><a href="#手动设置跟踪分支" class="headerlink" title="手动设置跟踪分支"></a>手动设置跟踪分支</h2><p>  可以通过 <code>git branch -vv</code> 来查看那些分支是跟踪分支。<br><img src="https://raw.githubusercontent.com/YVastness/picture-upload/main/ff70ba6ad9b24923be58593ea089f680.png" alt="在这里插入图片描述"><br>  第一列是本地分支名，第二列是该分支对应的 SHA-1 值，第三列[ ]中蓝色的就是跟踪的远程分支，之后跟着的是最后一次提交信息。</p><p>  可以通过<code>git branch --set-upstream-to=&lt;本地设置的远程仓库名&gt;/&lt;远程分支&gt; &lt;本地分支&gt;</code>命令为本地分支设置跟踪的远程分支。</p><h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><p>  如果不再需要某个远程分支了，比如搞定了某个特性并把它合并进了远程的 master 分支（或任何其他存放稳定代码的分支），可以用这个非常无厘头的语法来删除它：<code>git push [远程名] :[分支名]</code>。如果想在服务器上删除 serverfix 分支，运行下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :serverfix</span><br><span class="line">    To git@github.com:schacon/simplegit.git</span><br><span class="line">    - [deleted] serverfix</span><br></pre></td></tr></table></figure><p>咚！服务器上的分支没了。你最好特别留心这一页，因为你一定会用到那个命令，而且你很可能会忘掉它的语法。有种方便记忆这条命令的方法：记住我们不久前见过的 <code>git push [远程名] [本地分支]:[远程分支]</code> 语法，<strong>如果省略 [本地分支]，那就等于是在说“在这里提取空白然后把它变成[远程分支]”</strong>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h2 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h2><p>  <strong>用法</strong>：<code>git fetch &lt;远程仓库&gt;</code>。<br>  <strong>作用</strong>：获取远程仓库的更新到本地仓库中对应的<code>远程仓库/远程分支</code>这个分支上。<br>  PS：这个分支只能读，不能写。如果需要在这个分支上进行开发，可以在这个分支上新建一个本地分支，然后进行开发。</p><h2 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h2><p>  <strong>用法</strong>：<code>git pull &lt;远程仓库&gt; &lt;远程分支&gt;:&lt;本地分支&gt;</code>。<br>  PS:<code>:</code> 表示数据流向，上面的命令表示数据从远程分支流向本地分支。</p><p>  <strong>作用</strong>：获取指定的远程分支的更新并合并到本地分支上。</p><p>  <strong>省略</strong>：<br>  1. 如果指定的本地分支是当前分支，该命令可以省略为 <code>git pull &lt;远程仓库&gt; &lt;远程分支&gt;</code>。<br>  2. 如果当前分支是跟踪分支，该命令可以省略为 <code>git pull</code>。</p><h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><p>  <strong>用法</strong>：<code>git push &lt;远程仓库&gt; &lt;本地分支&gt;:&lt;远程分支&gt;</code>。<br>  PS:<code>:</code> 表示数据流向，上面的命令表示数据从本地分支流向远程分支。</p><p>  <strong>作用</strong>：将指定的本地分支推送到远程分支上。</p><p>  <strong>省略</strong>：<br>  1. 如果指定的本地分支和远程分支名相同，该命令可以省略为 <code>git push &lt;远程仓库&gt; &lt;本地分支&gt;</code>。<br>  2. 如果指定的本地分支是跟踪分支，该命令可以省略为 <code>git push</code>。<br>  3. 删除远程分支 <code>git push &lt;远程仓库&gt; :&lt;远程分支&gt;</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL执行计划(explain命令)中Type的浅析</title>
      <link href="/2022/11/11/MySQL%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92(explain%E5%91%BD%E4%BB%A4)%E4%B8%ADType%E7%9A%84%E6%B5%85%E6%9E%90/"/>
      <url>/2022/11/11/MySQL%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92(explain%E5%91%BD%E4%BB%A4)%E4%B8%ADType%E7%9A%84%E6%B5%85%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="Type-的相关知识点："><a href="#Type-的相关知识点：" class="headerlink" title="Type 的相关知识点："></a>Type 的相关知识点：</h3><blockquote><p>由上至下，性能由最差到最好</p></blockquote><table><thead><tr><th>Type</th><th>介绍</th></tr></thead><tbody><tr><td>ALL</td><td>Full Table Scan， MySQL将遍历全表以找到匹配的行</td></tr><tr><td>index</td><td>Full Index Scan，index与ALL区别为index类型只遍历索引树</td></tr><tr><td>range</td><td>索引范围扫描，对索引的扫描开始于某一点，返回匹配值域的行，常见于between、&lt;、&gt;等的查询</td></tr><tr><td>ref</td><td>非唯一性索引扫描，返回匹配某个单独值的所有行。常见于使用非唯一索引即唯一索引的非唯一前缀进行的查找</td></tr><tr><td>eq_ref</td><td>唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描</td></tr><tr><td>const、system</td><td>当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量</td></tr><tr><td>NULL</td><td>MySQL在优化过程中分解语句，执行时甚至不用访问表或索引</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC执行流程</title>
      <link href="/2022/11/11/SpringMVC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
      <url>/2022/11/11/SpringMVC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMVC执行流程"><a href="#SpringMVC执行流程" class="headerlink" title="SpringMVC执行流程"></a>SpringMVC执行流程</h1><p><img src="https://raw.githubusercontent.com/YVastness/picture-upload/main/image-20230321165224329-1679388748057-1-1679388752074-3-1679388755177-5.png" alt="image-20230321165224329"></p><p><img src="https://raw.githubusercontent.com/YVastness/picture-upload/main/image-20230321165319398-1679388801588-7-1679388804462-9.png" alt="image-20230321165319398"></p><p><img src="https://raw.githubusercontent.com/YVastness/picture-upload/main/20201125214311471.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
